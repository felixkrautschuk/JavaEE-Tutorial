%gibt an: Papierformat, einseitiger Druck, Schriftgröße
\documentclass[a4paper,oneside,titlepage,12pt]{article}
%-------------------------------------------------------------------
\usepackage[a4paper, top=2cm, footskip=0pt, headheight=0.8cm, headsep=0.6cm, lmargin=3cm, rmargin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{helvet}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{hyperref} 
\usepackage[right]{eurosym}
\usepackage[latin1]{inputenc}

%--------------------------------------------------------------------
\renewcommand{\baselinestretch}{1.2}

\begin{document}
%--------------------------------------------------------------------
%Titelseite
\begin{titlepage}
	\includegraphics{grafiken/HTW-Logo.png}
	%\includegraphics[width=.3\textwidth]{grafiken/HTW-Logo.png}
	\vspace*{3cm}
	\begin{center}
		\Huge{Android-Zusammenfassung\\} \vspace*{1cm}
		\huge{Felix Krautschuk\\}
		\small{(Matrikelnummer: 34230)}
		\vspace*{2cm}
		\normalsize{
			\\Studiengang Informatik\\
		}
	\end{center}
	\vspace{2cm}
\begin{center}
\large{ 5. Semester }
\end{center}
	\vspace*{3cm}



\end{titlepage}

\thispagestyle{empty}\clearpage

%----------------------------------------------------------------------------------------------------------------
%\rmfamily \pagestyle{fancy} \setcounter{secnumdepth}{4}
\newtheorem{satz}{Satz}
\newtheorem{lemma}[satz]{Lemma}
\newtheorem{folgerung}[satz]{Folgerung}
\theoremstyle{definition}
\newtheorem{definition}[satz]{Definition}
\numberwithin{equation}{section}
\renewcommand{\proofname}{Beweis}

\pagenumbering{roman}\setcounter{page}{3} \tableofcontents
\newcounter{roemisch} \setcounter{roemisch}{\value{page}}
\clearpage

\setcounter{page}{2} \pagenumbering{arabic}
%-----------------------------------------------------------------------------------------------------------------

\section{Programmstruktur - die wichtigsten Verzeichnisse und Dateien}
\includegraphics{grafiken/ordnerstruktur.jpg}

\subsection{AndroidManifest.xml}
Zu jeder App gehört eine zentrale Beschreibungsdatei. Sie enthält eine Liste der
Komponenten, aus denen das Programm besteht und befindet sich in der obersten
Ebene des Projektverzeichnisses. Außerdem werden in ihr die benötigten
Berechtigungen sowie etwaige zusätzlich verwendete Bibliotheken vermerkt. Auch
Angaben zur mindestens nötigen oder gewünschten Android-Version werden hier
eingetragen.
\\\includegraphics{grafiken/leereAppAndroidManifest}
\\Die Komponenten einer Anwendung sind Kinder des Elements
\textit{\textless application/\textgreater}. Wenn man im Assistenten zum Anlegen
neuer Projekte Create Activity mit einem Häkchen versieht und einen Namen
einträgt, enthält das Manifest ein Element \textit{\textless activity
/\textgreater}. Dessen Attribut android:name beinhaltet den im Assistenten
eingegebenen Activity-Namen. Wenn man manuell eine Activity-Klasse anlegt (eine
Klasse anlegt und mit \textit{extends Activity} versieht), muss man nachträglich
die erzeugte Activity im Manifest bekannt machen. Mithilfe des Elementes
\textit{\textless intent-filter /\textgreater} kann man eine Activity zur
Haupt-Activity machen. Dessen Kindelement \textit{\textless action
/\textgreater} kennzeichnet die Activity als Haupteinstiegspunkt in die
Anwendung. \textit{\textless category /\textgreater} sorgt dafür, dass sie im
Programmstarter angezeigt wird.

\subsection{strings.xml}
\includegraphics{grafiken/leereAppStrings.jpg}
\\\includegraphics{grafiken/leereAppStrings1.jpg}
\\Elemente haben einen Titel. Üblicherweise werden sämtliche Titel in die
String-Resource Datei \textit{string.xml} eingetragen und über
\textit{@string/\ldots} referenziert. Die Speicherung von Texten an einem
zentralen Ort hat zahlreiche Vorteile. Beispielsweise werden identische
Textteile leichter entdeckt, als wenn diese in den Quelltexten der Klassen
verborgen sind und man erst jede Klasse oder Layout-Datei durchsuchen muss.
Damit lässt sich, wenn auch in eher bescheidenem Umfang, Speicherplatz sparen.
Außerdem macht die Trennung von Daten und Programmlogik die
Internationalisierung, also die Übersetzung einer App in verschiedene Sprachen,
viel einfacher. Hierzu wird für jede zu unterstützende Sprache im Ordner
\textit{res} ein Verzeichnis angelegt.
Dessen Name beginnt mit \textit{values-} und endet mit dem ISO-Sprachschlüssel.
Für Deutsch ist dies \textit{de}. Das Verzeichnis muss also \textit{values-de}
heißen. Jeder dieser Ordner erhält eine eigene Version von \textit{strings.xml}.
Deren Bezeichner sind stets gleich, die Texte liegen hingegen in den jeweiligen
Sprachen vor. Texte in der Standardsprache verbleiben in \textit{values}.


\subsection{main.xml}
\includegraphics{grafiken/leereAppMenue2.jpg}
\\\includegraphics{grafiken/leereAppMenue.jpg}
\\Die \textit{main.xml} ist eine sogenannte Menu-Resource-Datei.
Menu-Resource-Dateien sind im Verzeichnis '\textit{src/menu}' hinterlegt und
dienen dazu Options-Menüs oder Kontextmenüs zu erstellen (Erläuterungen dazu im
späteren Kapitel Menüs), die man z.B. mit der Menütaste des Smartphones
betätigen aufrufen kann. Menü-Items sollten immer in solchen Menü-Dateien
aufgebaut werden statt in den Activity-Dateien. Man kann die erstellten Menüs
später in Activities oder Fragments einbinden.\\
Das Element \textit{\textless menu /\textgreater} dient dazu ein \textit{Menu}
anzulegen, welches einen Container für alle anderen Menü-Elemente. Es muss das
Wurzelelement der XML-Datei sein und es kann mehrere Elemente des Typs
\textit{item} oder \textit{group} enthalten.\\
Durch \textit{\textless item /\textgreater} wird ein Menü-Element angelegt,
welches widerum ein geschachteltes \textit{\textless menu /\textgreater}
enthalten kann, um quasi ein Submenü erstellen zu können.
\textit{item}-Elemente können widerum Attribute besitzen um deren
Erscheinungsbild und das Verhalten zu definieren, z.B. eine \textit{id}, ein
\textit{icon}, ein \textit{titel} (Resource-String in der string.xml
definieren!) oder \textit{showAsAction}, welches angibt wie ein Menü-Element in
der ActionBar erscheint und z.B. die Werte \textit{never}, \textit{always}
annehmen kann.\\
\textit{\textless group /\textgreater} ist ein optionaler,
nicht sichtbarer Container um Menü-Bestandteile zu kategorisieren, sodass diese
dann bestimmte Eigenschaften miteinander teilen können.


\subsection{activity\_main.xml}
\includegraphics{grafiken/leereActivityLayout.jpg}
\\\includegraphics{grafiken/leereActivityLayout2.jpg}
Die \textit{activity\_main.xml} ist die Layout-Datei der Main-Activity, also der
Startseite des Programmes. Hier können nun entweder über XML selbst (wie im
Bild) oder über den Designer View-Elemente hinzugefügt werden. Bei letzterer
Herangehensweise wird das XML-Dokument automatisch generiert, man kann sich also
die Oberfläche "zusammenklicken".\\
Das User-Interface besteht aus einem Wurzelelement, welches eine Art
Container für alle anderen View-Elemente darstellt.
Das Wurzelelement kann z.B. eine ViewGroup sein (LinearLayout,
ListView,\ldots). Auf jeden Fall muss die XML Datei den XML-Namespace
(\textit{xmlns =} \ldots) enthalten. Er Teil des öffnenden Tags des
Wurzelelementes. Desweiteren werden die Attribute \textit{layout\_width} und
\textit{layout\_heigth} benötigt.
Also sieht die kleinstmögliche Layout-Datei für die MainActivity folgendermaßen
aus:\\
\\\includegraphics{grafiken/leereActivityLayoutMindest.jpg}
\\Meistens bekommen die Attribute \textit{layout\_width} und
\textit{layout\_heigth} für das Wurzelelement beide den Wert
\textit{fill\_parent} damit das Layout den gesamten Bildschirm des Gerätes
einnimmt.



\section{Layouts, Views und Komponenten}
\subsection{Layouts}
Jede Android-App besteht aus mindestens einer oder mehreren Activities und
Layouts. Ein Layout ist ein Rahmen mit speziellen Eigenschaften zur Ausrichtung
und Anordnung von View- Elementen auf der Oberfläche. Es gibt in Android keine
Klasse Layout, jeder einzelne Layout-Typ ist eine eigene Klasse, die die Klasse
ViewGroup erweitert. Layouts können allerdings nicht nur View-Elemente
aufnehmen, sondern auch wieder Layouts. Damit ist eine Verschachtelung der
Oberflächenelemente möglich.\\
Folgende Layout-Tags sind möglich:
\begin{itemize}
  \item \textit{LinearLayout}: 
  \begin{itemize}
    \item alle View-Elemente, je nach Orientierung, Element für Element
    untereinander oder nebeneinander aneinandergereiht dargestellt
  \end{itemize}
  \item \textit{TableLayout}: 
  \begin{itemize}
    \item Möglichkeit, gleichförmig zusammenhängende
Oberflächen spalten- und zeilenbasiert zu erstellen (z.B. Eingabeformulare,\ldots)
  \end{itemize}
  \item \textit{GridLayout}:
  \begin{itemize}
    \item ähnlich dem TableLayout, kann jedoch so einfach wie das LinearLayout
    angewendet werden
    \item orientiert sich wie das TableLayout bei der Ausrichtung an Zeilen und
    Spalten
    \item Grafikelemente, die eine unterschiedliche Größe besitzen können sehr
    effizient positioniert werden
    \item Größe jeder einzelnen Zelle wird dynamisch angepasst
  \end{itemize}
  \item \textit{RelativeLayout}
  \begin{itemize}
    \item alle View-Elemente werden relativ zueinander positioniert
    \item Ausrichtung eines View-Elements erfolgt am äußeren Rahmen, der
    vertikalen bzw. der horizontalen Mitte oder dem vorhergehenden View-Element
  \end{itemize}
  \item \textit{FrameLayout}:
  \begin{itemize}
    \item einfachstes und performantestes Layout
    \item alle Layout-Elemente werden in der linken oberen Ecke ausgerichtet und
    übereinander gestapelt
  \end{itemize}
\end{itemize}



\subsection{Views}
Die Basisklasse aller Bedienelemente ist android.view.View. Die Benutzeroberfläche
einer App besteht also aus einer oder mehreren Views oder von ihr abgeleiteten
Klassen. Sie kümmern sich um die Bearbeitung von Tastatur-, Touch- und
Trackball-Ereignissen. Zum Ermitteln von Referenzen auf spezifische Komponenten
dient die Methode \textit{findViewById()}.



\subsection{Basiskomponenten einer App}
Jede Android-Anwendung besteht aus einem oder mehreren Bausteinen
(Basiskomponenten). Jede Basiskomponente kann mehrfach in einer
Android-Anwendung vorkommen. Alle Basiskomponenten haben einen Lebenszyklus
(Lifecycle). Diesen Lifecycle gilt es bei der Programmierung zu beachten.
Abhängig vom Lifecycle der Komponente entscheidet sich, ob Daten oder Funktionen
zur Laufzeit zur Verfügung stehen, oder ob diese verloren gehen.

\subsubsection{Activity}
Activities leiten von android.app.Activity oder deren Kindern ab.
Normalerweise ist jeder Activity eine Benutzeroberfläche, also ein Baum
bestehend aus Views und ViewGroups, zugeordnet. Activities bilden demnach die
vom Anwender wahrgenommenen Bausteine einer App.
Sie repräsentieren also meist die Benutzeroberfläche und Interaktionen. 
Jede Android- Anwendung besteht deshalb aus mindestens einer Activity.
Activities können andere Activities aufrufen und mit ihnen Daten austauschen.
Jede Activity besteht aus einer in XML definierten Layout-Datei und einer
dazugehörigen Java-Klassendatei, welche bei Android Studio im Verzeichnis
\\'\textit{\%Appname/src/main/java/\%packagename/}' abgelegt ist. Die
dazugehörige Layout-Datei (XML-Datei) ist im Verzeichnis
'\textit{\%Appname/src/main/res/layout}' zu finden.\\
Wichtige Methoden:
\begin{itemize}
  \item protected void onCreate(Bundle savedInstanceState)
  \begin{itemize}
    \item wird von praktisch jeder selbst geschriebenen Activity überschrieben
    \item Android ruft sie während der Initialisierungsphase einer Aktivität auf
    \item Aufgaben:
    \begin{itemize}
      \item Aufrufen der gleichnamigen Elternmethode: \textit{super.onCreate()},
      sonst gibt es zur Laufzeit eine SuperNotCalledException
      \item Initialisieren von Instanzvariablen mittels \textit{findViewById()}
      , z.B.\\buttonAdd = (Button) findViewById(R.id.buttonAdd);
      \item Setzen der Benutzeroberfläche durch\\
      \textit{setContentView(setContentView(R.layout. \textless
      Layout-Datei \textgreater )} \\wobei die Endung \textit{xml} weggelassen
      wird
      \item Wiederherstellen eines gespeicherten Zustands um Wiederanlaufzeiten
      einer Activity zu optimieren. Android stoppt Activities unter bestimmten
      Umständen automatisch, z.B. beim drehen des Gerätes, so wird vorher der
      Zustand in einem Zwischenspeicher \textit{savedInstanceState} gesichert.
    \end{itemize}
  \end{itemize}
  \item onCreateOptionsMenu(Menu menu)
  \begin{itemize}
    \item Ereignisbehandlung der Menüeinträge in der ActionBar erfolgt durch
    \textit{actions}
    \item diese Methode ist für die Erstellung des Menüs zuständig, es wird das
    Menü aufgeklappt und es werden Items hinzugefügt
  \end{itemize}
  \item onOptionsItemSelected(MenuItem item)
  \begin{itemize}
    \item wird immer dann ausgeführt, wenn ein Menü-Item betätigt wurde
    \item hier erfolgt die Ermittlung, welcher Menüeintrag betätigt wurde, z.B.
    mit \\switch(item.getItemId()) \{ case R.id.main\_menu\_about: \ldots \}
  \end{itemize}
\end{itemize}


\subsubsection{Events}
\begin{itemize}
  \item Klick-Ereignisse
  \begin{itemize}
    \item es muss festgelegt werden welche View-Elemente ein Klick-Ereignis
    auslösen und was mit diesem Ereignis geschehen soll
    \item man kann dem Attribut \textit{onClick} eines Items einen Wert
    zuweisen, z.B.
    \textit{onClick} (\textit{android:onClick="onClick"}), wodurch die Methode
    festgelegt wird, die bei einem Klick-Ereignis im Code aufgerufen werden soll 
	\item die Methode \textit{onClick(View view)} muss in jedem Fall in der
	Java-Klasse der Activity definiert werden
	\item man kann diese Methode auch mittels Erweiterung der Klasse durch
	\textit{implements View.onClickListener} implementieren
	\item hier ist eine switch/case-Anweisung sinnvoll, die die Id der View
	auswertet, erweitert\\
	switch (view.getId()) \{ case R.id.mainActionBar\_imageButton1:
	\ldots\}
  \end{itemize}
  \item Laden eines anderen Layouts (eine Activity) aus der aktuellen Activity
  mittels Intents (Definition \textit{Intent} im nächsten Abschnitt)
  \item Zustandsänderungen im System
\end{itemize}

\subsubsection{Intents}
Intents werden benötigt um eine Activity aus der aktuellen Activity zu starten
oder Informationen an eine andere Activity weiterzugeben.
Vereinfacht ausgedrückt sind Intents Nachrichten bzw Absichtserklärungen, welche
Aktion ausgeführt werden soll. Es gibt
\begin{itemize}
  \item Explizite Intents
  \begin{itemize}
    \item senden ihre Absicht an einen Empfänger
    \item der Empfänger muss explizit angegeben werden
    \item Empfänger können Komponenten einer Android-App, also Activities,
    Services oder BroadcastReceiver sein
    \item Empfänger wird über den voll qualifizierten Klassennamen angesprochen
    \item Beispiel\\
    		\includegraphics{grafiken/beispielExpliziteIntents.jpg}
    		\begin{itemize}
    		  \item mit dem Intent werden Informationen (.putExtra(\ldots)) an die
    		TestActivity übergeben (können verschiedenste Informationen sein)
    		\item Information werden als Key-Value-Paar übergeben
    		\item in der TestActivity ist es dann möglich, die übergebenen Informationen
    		auszuwerten
			\end{itemize}
  \end{itemize}
  \item Implizite Intents
\begin{itemize}
    \item senden ihre Nachricht/Absicht ab, aber der Empfänger steht noch nicht
    fest (es ist nicht klar welche Komponente genau sich der Nachricht annimmt)
    \item Beispiel bei Windows: nach einem Rechtsklick auf eine Datei, wählt
    man Senden an und dann E-Mail-Empfänger, so startet automatisch das
    Standard- E-Mail-Programm Ihres Systems
    \item Intents erklären, was ihre Absicht ist, und das System entscheidet,
    welche Komponente sich darum kümmert
    \item Beispiel\\
    		\includegraphics{grafiken/beispielImpliziteIntents.jpg}
    		\begin{itemize}
    		  \item impliziter Intent startet Browser und ruft die Web-Adresse
    		  \textit{www.scyte.eu} auf
    		\end{itemize}
  \end{itemize}
\end{itemize}
Mit einem expliziten Intent lässt sich aus einer Activity eine neue
Activity starten:\\
\includegraphics{grafiken/beispielActivityIntents.jpg}



\subsubsection{Fragments}
Fragments kann man als Teile einer Activity verstehen. Fragments bestehen,
wie auch Activities, aus einer Java-Datei und einem Layout und haben einen
Lebenszyklus (Lifecycle), der der Activity ähnlich ist. Jedoch benötigen
Fragments immer eine Activity, die sie umgibt und in deren Lifecycle sich
Fragments integrieren. Der Nutzen von Fragments liegt darin, dass Teile eines
Layouts mit Code in kleinere und wiederverwendbare Einheiten ausgliedert und
somit schneller und effizienter Anwendungen für verschiedene Gerätetypen oder
Displaymodi erstellt werden können. Mann kann diese Fragmente also in Layouts
für verschiedene Auflösungen und Orientierungen des Bildschirms einbinden und
wiederverwenden.\\
Fragmente leiten entweder direkt von der Basisklasse
\textit{android.app.Fragment} ab oder von einem ihrer spezialisierten Kinder,
beispielsweise \textit{ListFragment } oder \textit{DialogFragment}.
Beispiel:\\
\includegraphics{grafiken/fragmentBeispiel}
\\\textit{TestFragment} überschreibt zwei Methoden. \textit{onCreateView()} wird
aufgerufen, wenn ein Fragment den Komponentenbaum seiner Benutzeroberfläche
instanziieren soll.\\
Fragment in Activity in Activity einbetten:\\
\includegraphics{grafiken/fragmentInActivityEinbetten.jpg}
\\In diesem Ausschnitt wird das Fragment in die Layout-Datei einer Activity
eingebettet. Das Attribut android:name legt fest, welche Klasse das hier
definierte Fragment implementiert (nämlich die aus obigem Beispielcode).\\
Im Gegensatz zu Activities, Services oder Broadcast Receivern trägt man
Fragmente nicht in die Manifestdatei ein. Man verbindet sie mit einer Activity,
indem man sie in deren Benutzeroberfläche integriert. Dies geschieht
normalerweise deklarativ in Layoutdateien.


\subsubsection{Services}
Services haben kein User-Interface und dienen zur Abarbeitung von Aufgaben im
Hintergrund. Sie sind gerade für länger andauernde Tätigkeiten gedacht. Es gibt
2 Formen von Services:
\begin{itemize}
  \item Started:
  \begin{itemize}
  	\item wird von einer anderen Anwendungskomponente gestartet, läuft
  	eigenständig und beendet sich selbst nach Abarbeitung seiner Aufgabe
  \end{itemize}
  \item Bound:
  \begin{itemize}
    \item wird an eine oder mehrere Anwendungskomponenten mit bindService()
    gebunden und bietet eine Client-Service-Schnittstelle zur Kommunikation
    \item wird beendet, sobald keine Komponente mehr an ihn gebunden ist
  \end{itemize}
\end{itemize}
\includegraphics{grafiken/services.jpg}



\subsubsection{Menüs}
%drawables, icons für actionbars

Es gibt nun zwei Arten von Menüs, das Optionsmenü und das Kontextmenü. Das
Optionsmenü ist mit einer klassischen Menüleiste anderer Anwendungen vergleichbar und
sollte nur Funktionen enthalten, die für die aktuelle Activity sinnvoll sind.
Zusätzlich ist eine Hilfe- und Informationsseite der Anwendung sinnvoll. Das
Kontextmenü ist in klassischen Anwendungen meist durch einen Rechtsklick auf
ein Objekt aufrufbar. Dieser Rechtsklick wird in Android durch das lange
Antippen eines Objekts auf der Oberfläche ersetzt.

\paragraph{Optionsmenüs}
Die Erstellung eines Menüeintrages in der ActionBar ist schnell erledigt.
Standardmäßig wird vom Projektassistenten nämlich schon ein Menüeintrag in der
Mainactivity erstellt. 
\\Um das Optionsmenü für eine Activity zu spezifizieren, muss die Funktion
\textit{onCreateOptionsMenu(Menu menu)} überschrieben werden.\\
\\\includegraphics{grafiken/action_settings_mainActivity2.jpg}
\\Neue Menüeinträge müssen in der Datei \textit{main.xml}
definiert werden.\\
\\\includegraphics{grafiken/action_settings_menu.jpg}
\includegraphics{grafiken/action_settings_menu_layout.jpg}
\\Die Menüdefinition erfolgt durch \textit{\textless menu /\textgreater} Tags,
welche die Menüeinträge als \textit{\textless item /\textgreater} enthalten. Die
Items können selbst natürlich widerum Menüs enthalten, wodurch Untermenüs
entstehen.
\\Wie auf obigem Bild zu sehen
ist, wird das Menü aufgeklappt und damit der Menüeintrag \textit{Settings}
angezeigt sobald die Menütaste des Gerätes betätigt wird. Im XML-Quellcode der
Menü-Datei wird dies durch die Zeile \textit{android:showAsAction="never"}
festgelegt. Das Attribut \textit{android:showAsAction=" "} legt fest, wann und
wie der jeweilige Menüeintrag in der ActionBar angezeigt wird.
Man kann solche Menüeinträge auch für immer in der ActionBar anzeigen lassen,
ohne dass die Menütaste des Gerätes betätigt werden muss. Dies geschieht durch
Änderung der eben besprochenen Zeile in:
\textit{android:showAsAction="always"}.\\
\\\includegraphics{grafiken/action_settings_menu_layout_always.jpg}\\
\\Mit \textit{android:showAsAction="ifRoom"} werden die Menüeinträge in der
ActionBar angezeigt, sofern genügend Platz vorhanden ist. Ist dort nicht
genügend Platz vorhanden, wird der Eintrag in der Liste des Optionsmenüs
angezeigt.\\
Menüeinträge können auch \textbf{Icons} zugewiesen werden, die anstatt des
festgelegten Textes angezeigt werden, z.B. durch die Zeile
\textit{android:icon="@android:drawable/ic\_delete"}.
\\\includegraphics{grafiken/action_settings_menu_layout_icon.jpg}
\\Man kann auch eigene Icons erstellen und diese ins Programm einbinden. Hierzu
müssen diese in den folgenden Ordner eingefügt werden:
\\\includegraphics{grafiken/icons_ordner.jpg}\\
und die icons in der Menü-Ressourcendatei \textit{main.xml} beim entsprechenden
Menüelement(item) eingebunden werden.
\\\includegraphics{grafiken/icons_xml}. 
\\Um auf \textbf{Klickereignisse} reagieren zu können, muss die Funktion
\textit{onOptionsItemSelected(MenuItem item)} überschrieben werden.\\
\\\includegraphics{grafiken/action_settings_mainActivity.jpg}
\\Das vom Nutzer betätigte Menüelement kann mittels Aufruf der Funktion
\textit{getItemId} identifiziert werden. Sie gibt die eindeutige ID des
Menüelements zurück, welche durch das \textit{android:id} Attribut in der
Menü-Ressourcendatei \textit{main.xml} definiert wurde.

\paragraph{Kontextmenüs}
Sie werden im Gegensatz zu Optionsmenüs nicht durch Betätigen der Menütaste des
Gerätes (oder wie bei Windows durch die rechte Maustaste) ausgelöst, sondern
durch langes Antippen (Tippen und Halten) eines Elementes. Besonders beliebt
sind die Kontextmenüs im Zusammenhang mit ListView-Elementen. Aber natürlich
können auch das lange Antippen beliebiger View Elemente, z.B. Buttons, ein
Kontextmenü auslösen. 
Hierfür muss das jeweilige Viewelement an die Methode
\textit{registerForContextMenu} übergeben werden.\\
\\\includegraphics{grafiken/kontextmenuesRegister.jpg}\\
\ldots\\
\\Als nächstes muss die Methode \textit{onCreateContextMenu()} übrschrieben
werden. Hier muss das Menü angegeben werden, welches beim langen Antippen des
View-Elementes angezeigt werden soll.\\
\\\includegraphics{grafiken/kontextmenuesOnCreate.jpg}
\\Um auf \textbf{Klickereignisse} reagieren zu können muss die Methode
\textit{onContextItemSelected} überschrieben werden. Hier gibt man für jedes
Menü-Item des angezeigten Kontextmenüs an, was jeweils ausgeführt werden soll
(wie schon bei Optionsmenüs).\\
\\\includegraphics{grafiken/kontextmenuesOnContextItemSelected.JPG}




\section{Allgemeiner Ablauf bei einer einfachen Beispiel-App}
\subsection{Anlegen eines Projektes und Erstellung einer MainActivity}
1. Projekt anlegen:
\\\includegraphics{grafiken/neuesProjekt.jpg}\\
\\2. Basic-Activity-Layout auswählen:\\
Hier kann man nun zwischen verschiedensten Layouts für die MainActivity (also
das erste sichtbare Fenster) auswählen, z.B. ein Login-Fenster oder ein Fenster
mit einer Sidebar auf der linken Seite, etc \ldots . Meistens wählt man aber
die Blank Activity um sich ein individuelles Layout erstellen zu können.\\
\\\includegraphics{grafiken/neuesProjekt22.jpg}\\
\\3. Namen der Haupt-Activity (Java-Klasse) und der dazugehörigen
Layout Datei (XML) festlegen\\
\\\includegraphics{grafiken/neuesProjekt3.jpg}
\\Danach mit Finish den Vorgang abschließen und das Projekt ist angelegt.

\subsection{Layout festlegen und Views hinzufügen}
Layout festlegen
\subsection{ID und Namen eines jeden Views festlegen}
%string.xml!
\subsection{Einbinden der View-Elemente in die Activity-Klasse}
%findViewById(R.id. ..)
\subsection{Actionbar mit Image-Buttons erstellen}
%S. 76 Android Apps entwickeln Beispiel realer App
\subsection{Intents zum Aufruf einer Activity aus der aktuellen Activity}
\subsection{Anmelden der Activities im Manifest}


\end{document}
